/*
Gramatica actualizada para el Robot:
Adaptado para nueva sintaxis de comandos, variables, procedimientos y estructuras de control
Autor original: Alejandro Arango
Modificado por: Silvia Takahashi, Juan Pablo Morales






---------------------------------------------------------
Parser con instrucciones del robot modificadas por Sofi.
---------------------------------------------------------



*/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;
	private HashMap<String, Integer> variables = new HashMap<>();
	private HashMap<String, Procedure> procedures = new HashMap<>();

	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida = new String();

	class Procedure {
		String name;
		HashMap<String, Integer> paramValues;
		List<String> paramNames;
		HashMap<String, Integer> varLocales = new HashMap<>();
		List<String> body;

		Procedure(String name, HashMap<String, Integer> paramValues, List<String> paramNames, List<String> body)
		{
			this.name = name;
			this.paramNames = paramNames;
			this.body = body;
			this.paramValues = paramValues;
		}
	}
}
PARSER_END(Robot)

SKIP:
{
	" "
	| "\r"
	| "\t"
	| "\n"
}

TOKEN:
{
    <#LETTER: ["a"-"z", "A"-"Z"]>
    | <#DIGIT: ["0"-"9"]>
}

TOKEN: {
    <BREAK: "break">
    | <CONTINUE: "continue">
}



TOKEN: /* Comandos actualizados seg√∫n el enunciado */
{
    <MOVE: "move"> 
    | <TURN: "turn">
    | <FACE: "face">
    | <PUT: "put">
    | <PICK: "pick">
    | <POP: "pop">
    | <GOTO: "goto">
    | <JUMP: "jump">
    | <NOP: "nop">
    | <PROC: "proc">
    | <ASSIGN: ":=">
    | <IF: "if:">
    | <THEN: "then:">
    | <ELSE: "else:">
    | <WHILE: "while:">
    | <DO: "do:">
    | <FOR: "for:">
    | <INDIR: "inDir:">
    | <TOTHE: "toThe:">
    | <OFTYPE: "ofType:">
    | <REPEAT_BLOCK: "repeat:">
    | <ID: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    | <CONSTANT:  "#red" | "#green" | "#blue"> 
}

TOKEN:
{
    <BALLOONS: "#balloons">
    | <CHIPS: "#chips">
    | <BACK: "#back">
    | <FRONT: "#front">
    | <LEFT: "#left">
    | <RIGHT: "#right">
    | <AROUND: "#around">
    | <NORTH: "#north">
    | <SOUTH: "#south">
    | <WEST: "#west">
    | <EAST: "#east">
}

TOKEN: {
    <SUMA: "+"> | <RESTA: "-">
}




TOKEN:
{
    <NUM: (["0"-"9"])+ >
}

TOKEN:
{
    <CANMOVE: "canMove:">
  |  <FACING: "facing:">
  |  <CANPUT: "canPut:">
  |  <CANPICK: "canPick:">
  |  <CANJUMP: "canJump:">
  |  <NOT: "not:">
}


Token objType():
{
    Token t;
}
{
    t = <BALLOONS> { return t; } | t = <CHIPS> { return t; }
}


boolean command(Console sistema):
{
    boolean bool;
}
{
    variable_declaration(true, "") // declaro las variables globales al inicio
    { bool=true;
    	return bool;
    }
    
    | bool = interna(sistema, true, 1, "") 
    { return bool; }
}





boolean interna (Console sistema, boolean ejecutar, int numVecesEjecucion, String procName):
{
    int x, y, n;
    salida = new String();
    Token t;
    Token tok;
}
{

    (
        <MOVE> ":" x=expr(procName) moveIndirTothe(x, ejecutar) "." { salida = "Command: Move"; }
        
        | <TURN> ":" turnDirections(ejecutar) "." { salida = "Command: Turn"; }
        
        | <FACE> ":" faceDirections(ejecutar) "." { salida = "Command: Face"; }
        
        | <PUT> ":" n=expr(procName) <OFTYPE> t=objType() "." 
            { if (ejecutar) {
                if (n <= 0) throw new Error("PUT error: n debe ser mayor que 0");
                if (t.image.equals("#chips")) {
                    world.putChips(n);
                    salida = "Command: Put " + n + " chips"; 
                } else if (t.image.equals("#balloons")) {
                    world.putBalloons(n);
                    salida = "Command: Put " + n + " balloons"; 
                }
            }}
        | <PICK> ":" n=expr(procName) <OFTYPE> t=objType() "." 
            { if (ejecutar) {
                if (n <= 0) throw new Error("PICK error: n debe ser mayor que 0");
                if (t.image.equals("#chips")) {
                    world.pickChips(n);
                    salida = "Command: Pick " + n + " chips"; 
                } else if (t.image.equals("#balloons")) {
                    world.grabBalloons(n);
                    salida = "Command: Pick " + n + " balloons"; 
                }
            }}
        | <POP> ":" n=expr(procName) "."
            { if (ejecutar) { world.popBalloons(n); salida = "Command: Pop"; } }
            
        | <GOTO> ":" x=expr(procName) "with:" y=expr(procName) "."
            { if (ejecutar) { world.setPostion(x, y); salida = "Command: GoTo"; } }
            
        | <JUMP> ":" n=expr(procName) jumpIndirTothe(n, ejecutar) "." { salida = "Command: Jump"; }
        
        | <NOP> "." { salida = "Command: NOP"; }
        
        | procedure(sistema)
        
        | idTokenPath(procName) 
        
        | conditional(sistema, procName)
        
        | loop(sistema, procName)
    ) 
    {
        try { Thread.sleep(900); } 
        catch (InterruptedException e) { System.err.format("IOException: %s%n", e); }

        sistema.printOutput(salida);
        return true;
    } 
    | <EOF> { return false; }
}




void variable_declaration(boolean esGlobal, String procName):
{
    Token varName;
}
{

      "|" 
      ( varName=<ID> 
        { 
          if (esGlobal) { 
              variables.put(varName.image, 0);
          }
          else
          	procedures.get(procName).varLocales.put(varName.image, 0);
        }  
      )* 
      "|"

}



void assignment(Token varName, String procName):
{
    int valor;
}
{
    ":=" valor=expr(procName) "."
    {
        if (variables.containsKey(varName.image)) {  
            // Si es una variable global, actualiza su valor
            variables.put(varName.image, valor);
        } 
        else if (procedures.containsKey(procName) && procedures.get(procName).paramValues.containsKey(varName.image))
        {
          	//Caso de que es un parametro
          	procedures.get(procName).paramValues.put(varName.image, valor);
        }
        else if (procedures.containsKey(procName) && procedures.get(procName).varLocales.containsKey(varName.image))
        {
          //Caso de que es una variable local
          procedures.get(procName).varLocales.put(varName.image, valor);
       }
        else
        {
            throw new Error("Variable no definida: " + varName.image);
        }
    }
}




void procedure(Console sistema):
{
    Token procName;
    List<String> body = new ArrayList<>();
    HashMap<String, Integer > paramValues = new HashMap<String, Integer >();
    List<String > paramNames = new ArrayList<>(); 
}
{   
    <PROC> procName=<ID> ( ":" paramList(paramValues, paramNames) )* "[" 
    {
        procedures.put(procName.image, new Procedure(procName.image, paramValues, paramNames, body));
    }
    (variable_declaration(false, procName.image))? // Solo ejecuta si hay variables
    ( interna(sistema, true, 1, procName.image) )* "]"
}




void paramList(HashMap<String, Integer > paramValues, List<String> paramNames ):
{
	Token param;
}
{
	param=<ID>
		{ paramValues.put(param.image, 0);
		  paramNames.add(param.image);
		}
	(  (<ID> ":" | "with:") param=<ID>
		{ paramValues.put(param.image, 0);
		  paramNames.add(param.image);
		}
	)*
}

void idTokenPath(String procName):
{
  Token tok;
}
{
	( tok= <ID>  ) (assignment(tok, procName)| procCall(tok, procName) )
}

void procCall(Token procTok, String procName):
{
  int numParam=0;
  Procedure proc;
  int n;
  Token tok;
  String paramName;
}
{
	":" n=expr(procName)
		{if (!procedures.containsKey(procTok.image))
			throw new Error("No esta definido  el procedimiento " + procTok );
		else
			proc=procedures.get(procTok.image);

		if (proc.paramNames.size()< 1)
			throw new Error("Numero incorrecto de parametros");
			
		 numParam=1;
    	 paramName=proc.paramNames.get(0);
    	 proc.paramValues.put(paramName, n);
		}

	(< ID > ":" n=expr(procName)
		 { numParam+=1;
		 
		 if (proc.paramNames.size()< numParam)
			throw new Error("Numero incorrecto de parametros para este procedimiento");
		 
    	 paramName=proc.paramNames.get(numParam-1);
    	 proc.paramValues.put(paramName, n);
		 }
	)*
	"."
	  
	| "."
		{ if (!procedures.containsKey(procTok.image))
			throw new Error("No esta definido  el procedimiento " + procTok );
		}
	
}



///
///MOVE Y JUMP COMMANDS
///
void moveDirectionLRFB(int x, boolean ejecutar):
{
}
{
    <LEFT>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveHorizontally(-x, false) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(-x, false) ;
		      else 
		      	world.moveVertically(x, false) ;
		     }
	     }
    | <RIGHT>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveHorizontally(x, false) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(-x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(x, false) ;
		      else 
		      	world.moveVertically(-x, false) ;
		  	}
	     }
    | <FRONT>
	     { if (ejecutar)
	       	world.moveForward(x, false) ;
	     }
    | <BACK>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveVertically(x, false) ;
		      else if (world.getFacing()==1)
		      world.moveVertically(-x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveHorizontally(-x, false) ;
		      else 
		      	world.moveHorizontally(x, false) ;
		   }
	     }
}

void moveDirectionNESW(int x, boolean ejecutar):
{
}
{
		<EAST >
			 { if (ejecutar)
			 	{ world.moveHorizontally(x, false);
			 	changeFace(2); }
			}
		|  <WEST >
			{ if (ejecutar)
				{ world.moveHorizontally(-x, false);
				changeFace(3); }
			}
		|  <NORTH >
			{ if (ejecutar)
				{  world.moveVertically(-x, false);
				changeFace(0); }
			}
		| <SOUTH >
			{ if (ejecutar)
				{ world.moveVertically(x, false);
				changeFace(1); }
			}
}

void moveIndirTothe(int x, boolean ejecutar):
{
}
{
  < INDIR > moveDirectionNESW(x, ejecutar)
	| < TOTHE > moveDirectionLRFB(x, ejecutar)
	| { if (ejecutar)
			world.moveForward(x, false); }
}

void jumpIndirTothe(int x, boolean ejecutar):
{
}
{
        < INDIR > jumpDirectionNESW(x,ejecutar)
	| < TOTHE > jumpDirectionLRFB(x,ejecutar)
    | { world.moveForward(x, true); }
}


void jumpDirectionNESW(int x, boolean ejecutar):
{
}
{
		 <EAST >
		  { if (ejecutar)
		  	{ world.moveHorizontally(x, true);
		  	changeFace(2); }
		  }
		| <WEST >
			{ if (ejecutar)
				{ world.moveHorizontally(-x, true);
				changeFace(3); }
			}
		| <NORTH >
			{ if (ejecutar)
				{ world.moveVertically(-x, true);
				changeFace(0); }
			}
		| <SOUTH >
			{if (ejecutar)
				{  world.moveVertically(x, true);
				changeFace(1); }
			}
}

void jumpDirectionLRFB(int x, boolean ejecutar):
{
}
{
    <LEFT>
	    { if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveHorizontally(-x, true) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(-x, true) ;
		      else 
		      	world.moveVertically(x, true) ; }
	     }
    | <RIGHT>
	    {if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveHorizontally(x, true) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(-x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(x, true) ;
		      else 
		      	world.moveVertically(-x, true) ; }
	     }
    | <FRONT>
	     {if (ejecutar)
	       	world.moveForward(x, true) ;
	     }	
    | <BACK>
	    { if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveVertically(x, true) ;
		      else if (world.getFacing()==1)
		      world.moveVertically(-x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveHorizontally(-x, true) ;
		      else 
		      	world.moveHorizontally(x, true) ; }
	     }
}

///
//CONDITIONS Y LOOPS
//
void conditional(Console sistema, String procName):
{
  boolean bool;
  int numNot=0;
  boolean ejecutableIf=true;
  boolean ejecutableThen=false;
}
{
    <IF> numNot=notCondition() bool=conditions(procName)
    	{
    	  if (numNot%2!=0)
    	  	bool=!bool;
    	  if (bool)
    		{ ejecutableIf= true;
			ejecutableThen=false;
			}
		else
			{ ejecutableIf=false;
			ejecutableThen=true;
			}
    	}
    <THEN> "[" ( interna(sistema, ejecutableIf, 1, procName) )* "]" (<ELSE> "[" (interna(sistema, ejecutableThen, 1, procName))* "]")?
    
}

void loop(Console sistema, String procName):
{
    boolean bool;
    int numNot = 0;
    boolean ejecutable;
    int repeticiones;
}
{
    <WHILE> numNot = notCondition() bool = conditions(procName)
    {
        if (numNot % 2 != 0) {
            bool = !bool;
        }
        ejecutable = bool;
    }
    <DO> "[" ( interna(sistema, ejecutable, 1, procName) )*   "]"
}


int notCondition():
{
  int total=0;
}
{
	(<NOT> { total+=1; } )*

	{return total; }
}

boolean conditions(String procname):
{
  int x=0;
  boolean bool;
}
{	  <CANMOVE> x=expr(procname) bool=canMoveInDirToTheCondition(x) "." { return bool; }
	  |  <FACING>  bool=facingCondition() "." { return bool; }
	  |  <CANPUT> x=expr(procname) < OFTYPE >  bool=canPutCondition( x) "." { return bool; }
	  |  <CANPICK> x=expr(procname) < OFTYPE >  bool=canPickCondition( x) "." { return bool; }
	  |  <CANJUMP> x=expr(procname)  bool=canJumpInDirToTheCondition(x) "." { return bool; }
	
}

boolean canJumpInDirToTheCondition(int x):
{
  boolean bool;
}
{
	< INDIR > bool=canJumpNESWCondition(x) { return bool; }
	| < TOTHE > bool=canJumpLRFBCondition(x) { return bool; }
}

boolean canJumpNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() ||  world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canJumpLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}


boolean canMoveNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() || world.blockedInRange(pos.x, pos.y, newY, SOUTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.blockedInRange(pos.x, pos.y, newY, NORTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.blockedInRange(pos.x, pos.y, newX, EAST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.blockedInRange(pos.x, pos.y, newX, WEST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canMoveLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("LEFT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("RIGHT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("FRONT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("BACK");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}


boolean canMoveInDirToTheCondition(int x):
{  boolean bool;
}
{
	< INDIR > bool=canMoveNESWCondition( x) { return bool; }
	| < TOTHE > bool=canMoveLRFBCondition( x) { return bool ;}
}

boolean canPutCondition(int x):
{
}
{
  < BALLOONS > {if ( world.getMyBalloons()< x) return false; else return true; }
	|  < CHIPS > { if (x > world.freeSpacesForChips() ||  world.getMyChips()< x) return false; else return true;}
}

boolean canPickCondition(int x):
{
}
{
  < BALLOONS > { if (x > world.countBalloons()) return false; else return true;}
	|  < CHIPS > { if (x > world.chipsToPick()) return false; else return true;}
}

boolean facingCondition():
{
}
{
	< NORTH > { return world.facingNorth(); }
	| <SOUTH> { return world.facingSouth(); }
	| < EAST > { return world.facingEast(); }
	| < WEST > { return world.facingWest(); }
}

//
//OTROS
int expr(String procName):
{
    int total = 0;
    int valor;
    Token operador;
}
{
    valor = factor(procName) { total = valor; }
    { return total; }
}

int factor(String procName):
{
    int total = 0;
}
{
    ( <NUM> { total = Integer.parseInt(token.image); return total;}
    | <ID>
    {
        if (procName.equals(""))
        {
            if (!variables.containsKey(token.image))
            {
                throw new Error("Variable global no definida: " + token.image);
            }
            total = variables.get(token.image);
        }
        else 
        {
            if (!procedures.containsKey(procName) )
            {
                throw new Error("Variable '" + token.image + "' no definida en el procedimiento '" + procName + "'");
            }
            else if (procedures.get(procName).paramNames.contains(token.image))
            {
              total=procedures.get(procName).paramValues.get(token.image);
          	}
          	else if (variables.containsKey(token.image))
            {
                total=variables.get(token.image);
            }
          	else if (procedures.get(procName).varLocales.containsKey(token.image) )
          	{
          	  total=procedures.get(procName).varLocales.get(token.image);
            }
            else
            {
              throw new Error("Variable '" + token.image + "' no definida en el procedimiento '" + procName + "'");
           	}
        }

        return total;
    }
    )
    
}

//
//FACING RELATED
void changeFace(int dir):
{
}
{
  {
    while (world.getFacing()!=dir)
		world.turnRight();
  }
}

void faceDirections(boolean ejecutar):
{
}
{
 		 <WEST >  { if (ejecutar) changeFace(3); }
		|  <EAST >  { if (ejecutar) changeFace(2); }
		|  <NORTH >  { if (ejecutar) changeFace(0); }
		| <SOUTH >  { if (ejecutar) changeFace(1); }
}

void turnDirections(boolean ejecutar):
{
}
{
  	 <RIGHT>  { if (ejecutar) world.turnRight();}
  	| < LEFT >
  		{ if (ejecutar)
	    	{ world.turnRight();
	    	world.turnRight();
	    	world.turnRight();}
	  	}
  	| < AROUND >
  		{ if (ejecutar)
	    	{ world.turnRight();
	    	 world.turnRight(); }
	  	}
}


//
//AUXILIARES
//
int getCardinalDirHeaded(String dir):
{int facing;}
{
  {
  facing=world.getFacing();
  if (dir=="FRONT")
	return world.getFacing();

  else if (dir=="BACK")
  {
	if (facing==0)
		return 1;
	else if (facing==1)
		return 0;
	else if (facing==2)
		return 3;
	else
		return 2;
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		return 3;
	else if (facing==1)
		return 2;
	else if (facing==2)
		return 1;
	else 
		return 0;
		
  }
  
  else 
  {
	if (facing==0)
		return 2;
	else if (facing==1)
		return 3;
	else if (facing==2)
		return 0;
	else 
		return 1;
		
  }
  
} }

Point getNewPos( int steps, String dir):
{}
{
  {
  Point newPos= new Point(1,1);
  Point oldPos= world.getPosition();
  int facing = world.getFacing();

  if (dir=="FRONT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y-steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==2)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x-steps, oldPos.y);
		
  }

  else if (dir=="BACK")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y+steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==2)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x+steps, oldPos.y);
		
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x-steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y-steps);
		
  }
  
  else 
  {
	if (facing==0)
		newPos= new Point (oldPos.x+steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y+steps);
		
  }
  
  return newPos;
  
}
}


  
