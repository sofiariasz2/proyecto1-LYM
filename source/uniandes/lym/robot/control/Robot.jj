/*
Gramatica actualizada para el Robot:
Adaptado para nueva sintaxis de comandos, variables, procedimientos y estructuras de control
Autor original: Alejandro Arango
Modificado por: Silvia Takahashi, Juan Pablo Morales






---------------------------------------------------------
Parser con instrucciones del robot modificadas por Sofi.
---------------------------------------------------------



*/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;
	private HashMap<String, Integer> variables = new HashMap<>();
	private HashMap<String, Procedure> procedures = new HashMap<>();

	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida = new String();

	class Procedure {
		String name;
		List<String> parameters;
		List<String> body;

		Procedure(String name, List<String> parameters, List<String> body) {
			this.name = name;
			this.parameters = parameters;
			this.body = body;
		}
	}
}
PARSER_END(Robot)

SKIP:
{
	" "
	| "\r"
	| "\t"
	| "\n"
}

TOKEN:
{
    <#LETTER: ["a"-"z", "A"-"Z"]>
    | <#DIGIT: ["0"-"9"]>
}

TOKEN: {
    <BREAK: "break">
    | <CONTINUE: "continue">
}



TOKEN: /* Comandos actualizados según el enunciado */
{
    <MOVE: "move"> 
    | <TURN: "turn">
    | <FACE: "face">
    | <PUT: "put">
    | <PICK: "pick">
    | <POP: "pop">
    | <GOTO: "goto">
    | <JUMP: "jump">
    | <NOP: "nop">
    | <PROC: "proc">
    | <ASSIGN: ":=">
    | <IF: "if:">
    | <THEN: "then:">
    | <ELSE: "else:">
    | <WHILE: "while:">
    | <DO: "do:">
    | <FOR: "for:">
    | <INDIR: "inDir:">
    | <TOTHE: "toThe:">
    | <OFTYPE: "ofType:">
    | <REPEAT_BLOCK: "repeat:">
    | <ID: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    | <CONSTANT:  "#red" | "#green" | "#blue"> 
}

TOKEN:
{
    <BALLOONS: "#balloons">
    | <CHIPS: "#chips">
    | <BACK: "#back">
    | <FRONT: "#front">
    | <LEFT: "#left">
    | <RIGHT: "#right">
    | <AROUND: "#around">
    | <NORTH: "#north">
    | <SOUTH: "#south">
    | <WEST: "#west">
    | <EAST: "#east">
}

TOKEN: {
    <SUMA: "+"> | <RESTA: "-">
}




TOKEN:
{
    <NUM: (["0"-"9"])+ >
}

TOKEN:
{
    <CANMOVE: "canMove:">
  |  <FACING: "facing:">
  |  <CANPUT: "canPut:">
  |  <CANPICK: "canPick:">
  |  <CANJUMP: "canJump:">
  |  <NOT: "not:">
}


Token objType():
{
    Token t;
}
{
    t = <BALLOONS> { return t; } | t = <CHIPS> { return t; }
}


boolean command(Console sistema):
{
    boolean bool;
}
{
    variable_declaration(true, "") // declaro las variables globales al inicio
    | bool = interna(sistema, true, 1, "") 
    { return bool; }
}





boolean interna (Console sistema, boolean ejecutar, int numVecesEjecucion, String procName):
{
    int x, y, n;
    salida = new String();
    Token t;
}
{
    variable_declaration(false, procName)  // declara variables locales dentro del procedimiento

    (
        <MOVE> ":" x=expr(procName) moveIndirTothe(x, ejecutar) "." { salida = "Command: Move"; }
        
        | <TURN> ":" turnDirections(ejecutar) "." { salida = "Command: Turn"; }
        
        | <FACE> ":" faceDirections(ejecutar) "." { salida = "Command: Face"; }
        
        | <PUT> ":" n=expr(procName) <OFTYPE> t=objType() "." 
            { if (ejecutar) {
                if (n <= 0) throw new Error("PUT error: n debe ser mayor que 0");
                if (t.image.equals("#chips")) {
                    world.putChips(n);
                    salida = "Command: Put " + n + " chips"; 
                } else if (t.image.equals("#balloons")) {
                    world.putBalloons(n);
                    salida = "Command: Put " + n + " balloons"; 
                }
            }}
        | <PICK> ":" n=expr(procName) <OFTYPE> t=objType() "." 
            { if (ejecutar) {
                if (n <= 0) throw new Error("PICK error: n debe ser mayor que 0");
                if (t.image.equals("#chips")) {
                    world.pickChips(n);
                    salida = "Command: Pick " + n + " chips"; 
                } else if (t.image.equals("#balloons")) {
                    world.grabBalloons(n);
                    salida = "Command: Pick " + n + " balloons"; 
                }
            }}
        | <POP> ":" n=expr(procName) "."
            { if (ejecutar) { world.popBalloons(n); salida = "Command: Pop"; } }
            
        | <GOTO> ":" x=expr(procName) "with:" y=expr(procName) "."
            { if (ejecutar) { world.setPostion(x, y); salida = "Command: GoTo"; } }
            
        | <JUMP> ":" n=expr(procName) jumpIndirTothe(n, ejecutar) "." { salida = "Command: Jump"; }
        
        | <NOP> "." { salida = "Command: NOP"; }
        
        | procedure(sistema)
        
        | assignment(procName)  // Ahora las asignaciones pueden aparecer en cualquier punto
        
        | conditional(sistema, procName)
        
        | loop(sistema, procName)
    ) 
    {
        try { Thread.sleep(900); } 
        catch (InterruptedException e) { System.err.format("IOException: %s%n", e); }

        sistema.printOutput(salida);
        return true;
    } 
    | <EOF> { return false; }
}




void variable_declaration(boolean esGlobal, String procName):
{
    Token varName;
}
{
    LOOKAHEAD(3) // Indica a JavaCC que verifique más adelante antes de decidir
    (
      "|" 
      ( varName=<ID> "." 
        { 
          if (esGlobal) { 
              variables.put(varName.image, 0);
          } 
        }  
      )* 
      "|"
    )
    |
    (
      varName=<ID> ("," <ID> )* "." 
      { 
        if (!esGlobal) {  
            procedures.get(procName).parameters.add(varName.image);
        }
      }
    )
}



void assignment(String procName):
{
    Token varName;
    int valor;
}
{
    varName=<ID> ":=" valor=expr(procName) "."
    {
        if (variables.containsKey(varName.image)) {  
            // Si es una variable global, actualiza su valor
            variables.put(varName.image, valor);
        } 
        else if (procedures.containsKey(procName) && procedures.get(procName).parameters.contains(varName.image)) {  
            // Si es una variable local, se debería actualizar su valor, no agregarla como parámetro
            int index = procedures.get(procName).parameters.indexOf(varName.image);
            procedures.get(procName).parameters.set(index, varName.image);  // Mantiene la variable sin duplicarla
        }
        else {
            throw new Error("Variable no definida: " + varName.image);
        }
    }
}




void procedure(Console sistema):
{
    Token procName;
    List<String> params = new ArrayList<>();
    List<String> body = new ArrayList<>();
}
{   
    <PROC> procName=<ID> ( ":" paramList(params) )* "[" 
    {
        procedures.put(procName.image, new Procedure(procName.image, params, body));
    }
    (variable_declaration(false, procName.image))? // Solo ejecuta si hay variables
    ( interna(sistema, true, 1, procName.image) )* "]"
}




void paramList(List<String > params):
{
	Token param;
}
{
	param=<ID> { params.add(param.image); } (  (<ID> ":" | "with:") param=<ID> { params.add(param.image); } )*
}






void direction():
{
}
{
    <NORTH> | <SOUTH> | <EAST> | <WEST> | <LEFT> | <RIGHT> | <AROUND>
}

void directionLRFB():
{
}
{
    <LEFT> | <RIGHT> | <FRONT> | <BACK>
}

void moveDirectionLRFB(int x, boolean ejecutar):
{
}
{
    <LEFT>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveHorizontally(-x, false) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(-x, false) ;
		      else 
		      	world.moveVertically(x, false) ;
		     }
	     }
    | <RIGHT>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveHorizontally(x, false) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(-x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(x, false) ;
		      else 
		      	world.moveVertically(-x, false) ;
		  	}
	     }
    | <FRONT>
	     { if (ejecutar)
	       	world.moveForward(x, false) ;
	     }
    | <BACK>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveVertically(x, false) ;
		      else if (world.getFacing()==1)
		      world.moveVertically(-x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveHorizontally(-x, false) ;
		      else 
		      	world.moveHorizontally(x, false) ;
		   }
	     }
}

void moveDirectionNESW(int x, boolean ejecutar):
{
}
{
		<EAST >
			 { if (ejecutar)
			 	{ world.moveHorizontally(x, false);
			 	changeFace(2); }
			}
		|  <WEST >
			{ if (ejecutar)
				{ world.moveHorizontally(-x, false);
				changeFace(3); }
			}
		|  <NORTH >
			{ if (ejecutar)
				{  world.moveVertically(-x, false);
				changeFace(0); }
			}
		| <SOUTH >
			{ if (ejecutar)
				{ world.moveVertically(x, false);
				changeFace(1); }
			}
}

void moveIndirTothe(int x, boolean ejecutar):
{
}
{
  < INDIR > moveDirectionNESW(x, ejecutar)
	| < TOTHE > moveDirectionLRFB(x, ejecutar)
	| { if (ejecutar)
			world.moveForward(x, false); }
}

void jumpIndirTothe(int x, boolean ejecutar):
{
}
{
        < INDIR > jumpDirectionNESW(x,ejecutar)
	| < TOTHE > jumpDirectionLRFB(x,ejecutar)
    | { world.moveForward(x, true); }
}


void jumpDirectionNESW(int x, boolean ejecutar):
{
}
{
		 <EAST >
		  { if (ejecutar)
		  	{ world.moveHorizontally(x, true);
		  	changeFace(2); }
		  }
		| <WEST >
			{ if (ejecutar)
				{ world.moveHorizontally(-x, true);
				changeFace(3); }
			}
		| <NORTH >
			{ if (ejecutar)
				{ world.moveVertically(-x, true);
				changeFace(0); }
			}
		| <SOUTH >
			{if (ejecutar)
				{  world.moveVertically(x, true);
				changeFace(1); }
			}
}

void jumpDirectionLRFB(int x, boolean ejecutar):
{
}
{
    <LEFT>
	    { if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveHorizontally(-x, true) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(-x, true) ;
		      else 
		      	world.moveVertically(x, true) ; }
	     }
    | <RIGHT>
	    {if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveHorizontally(x, true) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(-x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(x, true) ;
		      else 
		      	world.moveVertically(-x, true) ; }
	     }
    | <FRONT>
	     {if (ejecutar)
	       	world.moveForward(x, true) ;
	     }	
    | <BACK>
	    { if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveVertically(x, true) ;
		      else if (world.getFacing()==1)
		      world.moveVertically(-x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveHorizontally(-x, true) ;
		      else 
		      	world.moveHorizontally(x, true) ; }
	     }
}

void directionNSEW():
{
}
{
    <NORTH> | <SOUTH> | <EAST> | <WEST> 
}






void conditional(Console sistema, String procName):
{
  boolean bool;
  int numNot=0;
  boolean ejecutableIf=true;
  boolean ejecutableThen=false;
}
{
    <IF> numNot=notCondition() bool=conditions(procname)
    	{
    	  if (numNot%2!=0)
    	  	bool=!bool;
    	  if (bool)
    		{ ejecutableIf= true;
			ejecutableThen=false;
			}
		else
			{ ejecutableIf=false;
			ejecutableThen=true;
			}
    	}
    <THEN> "[" ( interna(sistema, ejecutableIf, 1, procName) )* "]" (<ELSE> "[" (interna(sistema, ejecutableThen, 1, procName))* "]")?
    
}

void loop(Console sistema, String procName):
{
    boolean bool;
    int numNot = 0;
    boolean ejecutable;
    int repeticiones;
}
{
    <WHILE> numNot = notCondition() bool = conditions()
    {
        if (numNot % 2 != 0) {
            bool = !bool;
        }
        ejecutable = bool;
    }
    <DO> "[" 
        { 
            variable_declaration(false, procName) // Declara variables locales dentro del loop si las hay
            while (ejecutable)
            {
                if (!interna(sistema, true, 1, procName)) break;
                ejecutable = conditions(); // Reevaluar condición en cada iteración
            } 
        } 
        ( <BREAK> "." { return; } | <CONTINUE> "." { continue; } )*
    "]"
}


int notCondition():
{
  int total=0;
}
{
	(<NOT> { total+=1; } )*

	{return total; }
}

boolean conditions(String procname):
{
  int x=0;
  boolean bool;
}
{	  <CANMOVE> x=expr(procname) bool=canMoveInDirToTheCondition(x) "." { return bool; }
	  |  <FACING>  bool=facingCondition() "." { return bool; }
	  |  <CANPUT> x=expr(procname) < OFTYPE >  bool=canPutCondition( x) "." { return bool; }
	  |  <CANPICK> x=expr(procname) < OFTYPE >  bool=canPickCondition( x) "." { return bool; }
	  |  <CANJUMP> x=expr(procname)  bool=canJumpInDirToTheCondition(x) "." { return bool; }
	
}

boolean canJumpInDirToTheCondition(int x):
{
  boolean bool;
}
{
	< INDIR > bool=canJumpNESWCondition(x) { return bool; }
	| < TOTHE > bool=canJumpLRFBCondition(x) { return bool; }
}

boolean canJumpNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() ||  world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canJumpLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}


boolean canMoveNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() || world.blockedInRange(pos.x, pos.y, newY, SOUTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.blockedInRange(pos.x, pos.y, newY, NORTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.blockedInRange(pos.x, pos.y, newX, EAST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.blockedInRange(pos.x, pos.y, newX, WEST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canMoveLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("LEFT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("RIGHT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("FRONT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("BACK");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}

int getCardinalDirHeaded(String dir):
{int facing;}
{
  {
  facing=world.getFacing();
  if (dir=="FRONT")
	return world.getFacing();

  else if (dir=="BACK")
  {
	if (facing==0)
		return 1;
	else if (facing==1)
		return 0;
	else if (facing==2)
		return 3;
	else
		return 2;
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		return 3;
	else if (facing==1)
		return 2;
	else if (facing==2)
		return 1;
	else 
		return 0;
		
  }
  
  else 
  {
	if (facing==0)
		return 2;
	else if (facing==1)
		return 3;
	else if (facing==2)
		return 0;
	else 
		return 1;
		
  }
  
} }

Point getNewPos( int steps, String dir):
{}
{
  {
  Point newPos= new Point(1,1);
  Point oldPos= world.getPosition();
  int facing = world.getFacing();

  if (dir=="FRONT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y-steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==2)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x-steps, oldPos.y);
		
  }

  else if (dir=="BACK")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y+steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==2)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x+steps, oldPos.y);
		
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x-steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y-steps);
		
  }
  
  else 
  {
	if (facing==0)
		newPos= new Point (oldPos.x+steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y+steps);
		
  }
  
  return newPos;
  
}
}

boolean canMoveInDirToTheCondition(int x):
{  boolean bool;
}
{
	< INDIR > bool=canMoveNESWCondition( x) { return bool; }
	| < TOTHE > bool=canMoveLRFBCondition( x) { return bool ;}
}

boolean canPutCondition(int x):
{
}
{
  < BALLOONS > {if ( world.getMyBalloons()< x) return false; else return true; }
	|  < CHIPS > { if (x > world.freeSpacesForChips() ||  world.getMyChips()< x) return false; else return true;}
}

boolean canPickCondition(int x):
{
}
{
  < BALLOONS > { if (x > world.countBalloons()) return false; else return true;}
	|  < CHIPS > { if (x > world.chipsToPick()) return false; else return true;}
}

boolean facingCondition():
{
}
{
	< NORTH > { return world.facingNorth(); }
	| <SOUTH> { return world.facingSouth(); }
	| < EAST > { return world.facingEast(); }
	| < WEST > { return world.facingWest(); }
}
int expr(String procName):
{
    int total = 0;
    int valor;
    Token operador;
}
{
    valor = factor(procName) { total = valor; }
    (
        operador = <SUMA> valor = factor(procName)
        {
            if (operador.kind == SUMA) total += valor;
        }
        | operador = <RESTA> valor = factor(procName)
        {
            if (operador.kind == RESTA) total -= valor;
        }
    )*
    { return total; }
}

int factor(String procName):
{
    int total = 0;
}
{
    ( <NUM> { total = Integer.parseInt(token.image); }
    | <ID> {
        if (procName.isEmpty()) {
            if (!variables.containsKey(token.image)) {
                throw new Error("Variable global no definida: " + token.image);
            }
            total = variables.get(token.image);
        } else {
            if (!procedures.containsKey(procName) || 
                !procedures.get(procName).parameters.contains(token.image)) {
                throw new Error("Variable '" + token.image + "' no definida en el procedimiento '" + procName + "'");
            }
        }
    })
    { return total; }
}





void changeFace(int dir):
{
}
{
  {
    while (world.getFacing()!=dir)
		world.turnRight();
  }
}

void faceDirections(boolean ejecutar):
{
}
{
 		 <WEST >  { if (ejecutar) changeFace(3); }
		|  <EAST >  { if (ejecutar) changeFace(2); }
		|  <NORTH >  { if (ejecutar) changeFace(0); }
		| <SOUTH >  { if (ejecutar) changeFace(1); }
}

void turnDirections(boolean ejecutar):
{
}
{
  	 <RIGHT>  { if (ejecutar) world.turnRight();}
  	| < LEFT >
  		{ if (ejecutar)
	    	{ world.turnRight();
	    	world.turnRight();
	    	world.turnRight();}
	  	}
  	| < AROUND >
  		{ if (ejecutar)
	    	{ world.turnRight();
	    	 world.turnRight(); }
	  	}
}





  
