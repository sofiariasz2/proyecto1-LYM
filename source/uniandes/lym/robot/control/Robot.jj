/*
Gramatica actualizada para el Robot:
Adaptado para nueva sintaxis de comandos, variables, procedimientos y estructuras de control
Autor original: Alejandro Arango
Modificado por: Silvia Takahashi, Juan Pablo Morales






---------------------------------------------------------
Parser con instrucciones del robot modificadas por Sofi.
---------------------------------------------------------



*/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;
	private HashMap<String, Integer> variables = new HashMap<>();
	private HashMap<String, Procedure> procedures = new HashMap<>();

	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida = new String();

	class Procedure {
		String name;
		List<String> parameters;
		List<String> body;

		Procedure(String name, List<String> parameters, List<String> body) {
			this.name = name;
			this.parameters = parameters;
			this.body = body;
		}
	}
}
PARSER_END(Robot)

SKIP:
{
	" "
	| "\r"
	| "\t"
	| "\n"
}

TOKEN:
{
    <#LETTER: ["a"-"z", "A"-"Z"]>
    | <#DIGIT: ["0"-"9"]>
}

TOKEN: /* Comandos actualizados seg√∫n el enunciado */
{
    <MOVE: "move"> 
    | <TURN: "turn">
    | <FACE: "face">
    | <PUT: "put">
    | <PICK: "pick">
    | <POP: "pop">
    | <GOTO: "goto">
    | <JUMP: "jump">
    | <NOP: "nop">
    | <PROC: "proc">
    | <ASSIGN: ":=">
    | <IF: "if:">
    | <THEN: "then:">
    | <ELSE: "else:">
    | <WHILE: "while:">
    | <DO: "do:">
    | <FOR: "for:">
    | <INDIR: "inDir:">
    | <TOTHE: "toThe:">
    | <OFTYPE: "ofType:">
    | <REPEAT_BLOCK: "repeat:">
    | <ID: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    | <CONSTANT:  "#red" | "#green" | "#blue"> 
}

TOKEN:
{
    <BALLOONS: "#balloons">
    | <CHIPS: "#chips">
    | <BACK: "#back">
    | <FRONT: "#front">
    | <LEFT: "#left">
    | <RIGHT: "#right">
    | <AROUND: "#around">
    | <NORTH: "#north">
    | <SOUTH: "#south">
    | <WEST: "#west">
    | <EAST: "#east">
}


TOKEN:
{
    <NUM: (["0"-"9"])+ >
}

TOKEN:
{
    <CANMOVE: "canMove:">
  |  <FACING: "facing:">
  |  <CANPUT: "canPut:">
  |  <CANPICK: "canPick:">
  |  <CANJUMP: "canJump:">
  |  <NOT: "not:">
}


Token objType():
{
    Token t;
}
{
    t = <BALLOONS> { return t; } | t = <CHIPS> { return t; }
}


boolean command(Console sistema):
{
	int x, y, n;
	salida = new String();
	Token t;
}
{
	(
		<MOVE> ":" x=expr() moveIndirTothe(x) "." { salida = "Command: Move"; }
		
		| <TURN> ":" turnDirections() "." { salida = "Command: Turn"; }
		
		| <FACE> ":" faceDirections() "." { salida = "Command: Face"; }
		
		| <PUT> ":" n=expr() <OFTYPE> t=objType() "." 
		    { 
		        if (n <= 0) {
		        
		            throw new Error("PUT error: n debe ser mayor que 0");
		        }
		        if (t.image.equals("#chips")) {
		            world.putChips(n);
		            salida = "Command: Put " + n + " chips"; 
		        } else if (t.image.equals("#balloons")) {
		            world.putBalloons(n);
		            salida = "Command: Put " + n + " balloons"; 
		        }
		    }

		| <PICK> ":" n=expr() <OFTYPE> t=objType() "." 
		
		    { 
		        
		        if (n <= 0) {
		        
		            throw new Error("PICK error: n debe ser mayor que 0");
		        }
		        
		        if (t.image.equals("#chips")) {
		            world.pickChips(n);
		            salida = "Command: Pick " + n + " chips"; 
		        } else if (t.image.equals("#balloons")) {
		            world.grabBalloons(n);
		            salida = "Command: Pick " + n + " balloons"; 
		        }
		    }
		    
		| <POP> ":" n=expr() "." { world.popBalloons(n); salida = "Command: Pop"; }
		| <GOTO> ":" x=expr() "with:" y=expr() "." { world.setPostion(x, y); salida = "Command: GoTo"; }
		
		| <JUMP> ":" n=expr() jumpIndirTothe(n) "." { salida = "Command: Jump"; }

		
		| <NOP> "." { salida = "Command: NOP"; }
		| procedure(sistema)
		| variable_declaration()
		//| assignment()
		| conditional(sistema)
		| loop(sistema)
	) 
	{
		try {
			Thread.sleep(900);
		} catch (InterruptedException e) {
			System.err.format("IOException: %s%n", e);
		}

		sistema.printOutput(salida);
		return true;
	} 
	| <EOF> { return false; }
}

void procedure(Console sistema):
{
	Token procName;
	List<String> params = new ArrayList<>();
	List<String> body = new ArrayList<>();
}
{	
	<PROC> procName=<ID> ( ":" paramList(params) )* "[" ( command(sistema) )* "]" {
    procedures.put(procName.image, new Procedure(procName.image, params, body));
}
	
}

void paramList(List<String > params):
{
	Token param;
}
{
	param=<ID> { params.add(param.image); } (  (<ID> ":" | "with:") param=<ID> { params.add(param.image); } )*
}

void direction():
{
}
{
    <NORTH> | <SOUTH> | <EAST> | <WEST> | <LEFT> | <RIGHT> | <AROUND>
}

void directionLRFB():
{
}
{
    <LEFT> | <RIGHT> | <FRONT> | <BACK>
}

void moveDirectionLRFB(int x):
{
}
{
    <LEFT>
	    {
	      if (world.getFacing()==0)
	      	world.moveHorizontally(-x, false) ;
	      else if (world.getFacing()==1)
	      	world.moveHorizontally(x, false) ;
	      else if (world.getFacing()==2)
	      	world.moveVertically(-x, false) ;
	      else 
	      	world.moveVertically(x, false) ;
	     }
    | <RIGHT>
	    {
	      if (world.getFacing()==0)
	      	world.moveHorizontally(x, false) ;
	      else if (world.getFacing()==1)
	      	world.moveHorizontally(-x, false) ;
	      else if (world.getFacing()==2)
	      	world.moveVertically(x, false) ;
	      else 
	      	world.moveVertically(-x, false) ;
	     }
    | <FRONT>
	     {
	       world.moveForward(x, false) ;
	     }
    | <BACK>
	    {
	      if (world.getFacing()==0)
	      	world.moveVertically(x, false) ;
	      else if (world.getFacing()==1)
	      world.moveVertically(-x, false) ;
	      else if (world.getFacing()==2)
	      	world.moveHorizontally(-x, false) ;
	      else 
	      	world.moveHorizontally(x, false) ;
	     }
}

void moveDirectionNESW(int x):
{
}
{
		 <EAST > { world.moveHorizontally(x, false); changeFace(2); }
		|  <WEST > { world.moveHorizontally(-x, false); changeFace(3); }
		|  <NORTH >  { world.moveVertically(-x, false); changeFace(0); }
		| <SOUTH > { world.moveVertically(x, false); changeFace(1); }
}

void moveIndirTothe(int x):
{
}
{
  < INDIR > moveDirectionNESW(x)
	| < TOTHE > moveDirectionLRFB(x)
	| { world.moveForward(x, false); }
}

void jumpIndirTothe(int x):
{
}
{
        < INDIR > jumpDirectionNESW(x)
	| < TOTHE > jumpDirectionLRFB(x)
    | { world.moveForward(x, true); }
}


void jumpDirectionNESW(int x):
{
}
{
		  <EAST >  { world.moveHorizontally(x, true); changeFace(2); }
		| <WEST > { world.moveHorizontally(-x, true); changeFace(3); }
		| <NORTH > { world.moveVertically(-x, true); changeFace(0); }
		| <SOUTH >  { world.moveVertically(x, true); changeFace(1); }
}

void jumpDirectionLRFB(int x):
{
}
{
    <LEFT>
	    {
	      if (world.getFacing()==0)
	      	world.moveHorizontally(-x, true) ;
	      else if (world.getFacing()==1)
	      	world.moveHorizontally(x, true) ;
	      else if (world.getFacing()==2)
	      	world.moveVertically(-x, true) ;
	      else 
	      	world.moveVertically(x, true) ;
	     }
    | <RIGHT>
	    {
	      if (world.getFacing()==0)
	      	world.moveHorizontally(x, true) ;
	      else if (world.getFacing()==1)
	      	world.moveHorizontally(-x, true) ;
	      else if (world.getFacing()==2)
	      	world.moveVertically(x, true) ;
	      else 
	      	world.moveVertically(-x, true) ;
	     }
    | <FRONT>
	     {
	       world.moveForward(x, true) ;
	     }
    | <BACK>
	    {
	      if (world.getFacing()==0)
	      	world.moveVertically(x, true) ;
	      else if (world.getFacing()==1)
	      world.moveVertically(-x, true) ;
	      else if (world.getFacing()==2)
	      	world.moveHorizontally(-x, true) ;
	      else 
	      	world.moveHorizontally(x, true) ;
	     }
}

void directionNSEW():
{
}
{
    <NORTH> | <SOUTH> | <EAST> | <WEST> 
}



void variable_declaration():
{
}
{
    <ID> ("," <ID>)* ":=" expr() "."
}

/*
void assignment():
{
}
{
    <ID> ":=" expr() "."
}
*/

void conditional(Console sistema):
{
}
{
    <IF> (<NOT>)* conditions() <THEN> "[" (command(sistema))* "]" (<ELSE> "[" (command(sistema))* "]")?
    
}

void loop(Console sistema):
{
}
{
  <WHILE> (<NOT>)* conditions() <DO> "[" (command(sistema))* "]"

    | <FOR> expr() <REPEAT_BLOCK> "[" (command(sistema))* "]"
    
}

boolean conditions():
{
  int x=0;
  boolean bool;
}
{	  <CANMOVE> x=expr() bool=canMoveInDirToTheCondition(x) { return bool; }
	  |  <FACING>  bool=facingCondition() { return bool; }
	  |  <CANPUT> x=expr() < OFTYPE >  bool=canPutCondition( x) { return bool; }
	  |  <CANPICK> x=expr() < OFTYPE >  bool=canPickCondition( x) { return bool; }
	  |  <CANJUMP> x=expr()  bool=canJumpInDirToTheCondition(x) { return bool; }
	
}

boolean canJumpInDirToTheCondition(int x):
{
  boolean bool;
}
{
	< INDIR > bool=canJumpNESWCondition(x) { return bool; }
	| < TOTHE > bool=canJumpLRFBCondition(x) { return bool; }
}

boolean canJumpNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() ||  world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canJumpLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}


boolean canMoveNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() || world.blockedInRange(pos.x, pos.y, newY, SOUTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.blockedInRange(pos.x, pos.y, newY, NORTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.blockedInRange(pos.x, pos.y, newX, EAST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.blockedInRange(pos.x, pos.y, newX, WEST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canMoveLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("LEFT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("RIGHT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("FRONT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("BACK");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}

int getCardinalDirHeaded(String dir):
{int facing;}
{
  {
  facing=world.getFacing();
  if (dir=="FRONT")
	return world.getFacing();

  else if (dir=="BACK")
  {
	if (facing==0)
		return 1;
	else if (facing==1)
		return 0;
	else if (facing==2)
		return 3;
	else
		return 2;
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		return 3;
	else if (facing==1)
		return 2;
	else if (facing==2)
		return 1;
	else 
		return 0;
		
  }
  
  else 
  {
	if (facing==0)
		return 2;
	else if (facing==1)
		return 3;
	else if (facing==2)
		return 0;
	else 
		return 1;
		
  }
  
} }

Point getNewPos( int steps, String dir):
{}
{
  {
  Point newPos= new Point(1,1);
  Point oldPos= world.getPosition();
  int facing = world.getFacing();

  if (dir=="FRONT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y-steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==2)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x-steps, oldPos.y);
		
  }

  else if (dir=="BACK")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y+steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==2)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x+steps, oldPos.y);
		
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x-steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y-steps);
		
  }
  
  else 
  {
	if (facing==0)
		newPos= new Point (oldPos.x+steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y+steps);
		
  }
  
  return newPos;
  
}
}

boolean canMoveInDirToTheCondition(int x):
{  boolean bool;
}
{
	< INDIR > bool=canMoveNESWCondition( x) { return bool; }
	| < TOTHE > bool=canMoveLRFBCondition( x) { return bool ;}
}

boolean canPutCondition(int x):
{
}
{
  < BALLOONS > {if ( world.getMyBalloons()< x) return false; else return true; }
	|  < CHIPS > { if (x > world.freeSpacesForChips() ||  world.getMyChips()< x) return false; else return true;}
}

boolean canPickCondition(int x):
{
}
{
  < BALLOONS > { if (x > world.countBalloons()) return false; else return true;}
	|  < CHIPS > { if (x > world.chipsToPick()) return false; else return true;}
}

boolean facingCondition():
{
}
{
	< NORTH > { return world.facingNorth(); }
	| <SOUTH> { return world.facingSouth(); }
	| < EAST > { return world.facingEast(); }
	| < WEST > { return world.facingWest(); }
}

int expr():
{
	int total = 1;
}
{
	( <NUM> { total = Integer.parseInt(token.image); }
	| <ID> { if (!variables.containsKey(token.image)) throw new Error("Variable no definida: " + token.image); total = variables.get(token.image); }
	)
	{ return total; }
}

int expr(String procName):
{
	int total = 1;
}
{
	( <NUM> { total = Integer.parseInt(token.image); }
	| <ID> { if (!variables.containsKey(token.image)) throw new Error("Variable no definida: " + token.image); total = variables.get(token.image); }
	)
	{ return total; }
}

void changeFace(int dir):
{
}
{
  {
    while (world.getFacing()!=dir)
		world.turnRight();
  }
}

void faceDirections():
{
}
{
 		 <WEST >  { changeFace(3); }
		|  <EAST >  { changeFace(2); }
		|  <NORTH >  { changeFace(0); }
		| <SOUTH >  { changeFace(1); }
}

void turnDirections():
{
}
{
  	 <RIGHT>  { world.turnRight();}
  	| < LEFT >  { world.turnRight(); world.turnRight(); world.turnRight();}
  	| < AROUND > { world.turnRight(); world.turnRight(); }
}





  
