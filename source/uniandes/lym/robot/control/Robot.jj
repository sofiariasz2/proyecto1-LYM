/*
Gramatica actualizada para el Robot:
Adaptado para nueva sintaxis de comandos, variables, procedimientos y estructuras de control
Autor original: Alejandro Arango
Modificado por: Silvia Takahashi, Juan Pablo Morales






---------------------------------------------------------
Parser con instrucciones del robot modificadas por Sofi.
---------------------------------------------------------



*/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;
	private HashMap<String, Integer> variables = new HashMap<>();
	private HashMap<String, Procedure> procedures = new HashMap<>();

	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida = new String();

	class Procedure {
		String name;
		List<String> parameters;
		List<String> body;

		Procedure(String name, List<String> parameters, List<String> body) {
			this.name = name;
			this.parameters = parameters;
			this.body = body;
		}
	}
}
PARSER_END(Robot)

SKIP:
{
	" "
	| "\r"
	| "\t"
	| "\n"
}

TOKEN:
{
    <#LETTER: ["a"-"z", "A"-"Z"]>
    | <#DIGIT: ["0"-"9"]>
}

TOKEN: /* Comandos actualizados según el enunciado */
{
    <MOVE: "move"> 
    | <TURN: "turn">
    | <FACE: "face">
    | <PUT: "put">
    | <PICK: "pick">
    | <POP: "pop">
    | <GOTO: "goto">
    | <JUMP: "jump">
    | <NOP: "nop">
    | <PROC: "proc">
    | <ASSIGN: ":=">
    | <IF: "if:">
    | <THEN: "then:">
    | <ELSE: "else:">
    | <WHILE: "while:">
    | <DO: "do:">
    | <FOR: "for:">
    | <INDIR: "inDir:">
    | <TOTHE: "toThe:">
    | <OFTYPE: "ofType:">
    | <REPEAT_BLOCK: "repeat:">
    | <ID: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    | <CONSTANT:  "#red" | "#green" | "#blue"> 
}

TOKEN:
{
    <BALLOONS: "#balloons">
    | <CHIPS: "#chips">
    | <BACK: "#back">
    | <FRONT: "#front">
    | <LEFT: "#left">
    | <RIGHT: "#right">
    | <AROUND: "#around">
    | <NORTH: "#north">
    | <SOUTH: "#south">
    | <WEST: "#west">
    | <EAST: "#east">
}


TOKEN:
{
    <NUM: (["0"-"9"])+ >
}

TOKEN:
{
    <CANMOVE: "canMove:">
  |  <FACING: "facing:">
  |  <CANPUT: "canPut:">
  |  <CANPICK: "canPick:">
  |  <CANJUMP: "canJump:">
  |  <NOT: "not:">
}


Token objType():
{
    Token t;
}
{
    t = <BALLOONS> { return t; } | t = <CHIPS> { return t; }
}


boolean command(Console sistema):
{
    boolean bool;
}
{
    global_variable_declaration()  // Ahora reconoce las variables globales antes de ejecutar comandos
    | bool = interna(sistema, true, 1, "")  // Luego ejecuta los comandos
    { return bool; }
}

boolean interna (Console sistema, boolean ejecutar, int numVecesEjecucion, String procName):
{
    int x, y, n;
    salida = new String();
    Token t;
}
{
    (
        <MOVE> ":" x=expr(procName) moveIndirTothe(x, ejecutar) "." { salida = "Command: Move"; }
        
        | <TURN> ":" turnDirections(ejecutar) "." { salida = "Command: Turn"; }
        
        | <FACE> ":" faceDirections(ejecutar) "." { salida = "Command: Face"; }
        
        | <PUT> ":" n=expr(procName) <OFTYPE> t=objType() "." 
            { if (ejecutar)
                { 
                    if (n <= 0) {
                        throw new Error("PUT error: n debe ser mayor que 0");
                    }
                    if (t.image.equals("#chips")) {
                        world.putChips(n);
                        salida = "Command: Put " + n + " chips"; 
                    } else if (t.image.equals("#balloons")) {
                        world.putBalloons(n);
                        salida = "Command: Put " + n + " balloons"; 
                    }
                }
            }

        | <PICK> ":" n=expr(procName) <OFTYPE> t=objType() "." 
        
            { if (ejecutar)
                { 
                    if (n <= 0) {
                        throw new Error("PICK error: n debe ser mayor que 0");
                    }
                    
                    if (t.image.equals("#chips")) {
                        world.pickChips(n);
                        salida = "Command: Pick " + n + " chips"; 
                    } else if (t.image.equals("#balloons")) {
                        world.grabBalloons(n);
                        salida = "Command: Pick " + n + " balloons"; 
                    }
                }
            }
            
        | <POP> ":" n=expr(procName) "."
            {if (ejecutar)
                {  world.popBalloons(n);
                salida = "Command: Pop"; }
            }

        | <GOTO> ":" x=expr(procName) "with:" y=expr(procName) "."
            { if (ejecutar)
                 { world.setPostion(x, y);
                 salida = "Command: GoTo"; }
            }
        
        | <JUMP> ":" n=expr(procName) jumpIndirTothe(n, ejecutar) "." { salida = "Command: Jump"; }

        
        | <NOP> "." { salida = "Command: NOP"; }
        | procedure(sistema)
        | variable_declaration()
        //| assignment()
        | conditional(sistema, procName)
        | loop(sistema, procName)
    ) 
    {
        try {
            Thread.sleep(900);
        } catch (InterruptedException e) {
            System.err.format("IOException: %s%n", e);
        }

        sistema.printOutput(salida);
        return true;
    } 
    | <EOF> { return false; }
}


void procedure(Console sistema):
{
    Token procName;
    List<String> params = new ArrayList<>();
    List<String> body = new ArrayList<>();
}
{	
    <PROC> procName=<ID> ( ":" paramList(params) )* "[" 
        { procedures.put(procName.image, new Procedure(procName.image, params, body)); }
        ( interna(sistema, true, 1, procName.image) )* 
    "]"

    // Llamada a un procedimiento
    | procName=<ID> "(" (paramList(params))? ")" "."
    {
        if (!procedures.containsKey(procName.image)) {
            throw new Error("Procedimiento no definido: " + procName.image);
        }
        interna(sistema, true, 1, procName.image);
    }
}


void paramList(List<String > params):
{
	Token param;
}
{
	param=<ID> { params.add(param.image); } (  (<ID> ":" | "with:") param=<ID> { params.add(param.image); } )*
}

void variable_declaration(String procName):
{
    Token varName;
}
{
    varName=<ID> ( "," <ID> )* ":=" expr(procName) "."
    {
        if (procName.isEmpty()) {
            variables.put(varName.image, 0);
        } else {
            procedures.get(procName).parameters.add(varName.image);
        }
    }
}

void global_variable_declaration():
{
    Token varName;
}
{
    "|" 
    ( varName=<ID> { variables.put(varName.image, 0); } )* 
    "|"
}




void direction():
{
}
{
    <NORTH> | <SOUTH> | <EAST> | <WEST> | <LEFT> | <RIGHT> | <AROUND>
}

void directionLRFB():
{
}
{
    <LEFT> | <RIGHT> | <FRONT> | <BACK>
}

void moveDirectionLRFB(int x, boolean ejecutar):
{
}
{
    <LEFT>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveHorizontally(-x, false) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(-x, false) ;
		      else 
		      	world.moveVertically(x, false) ;
		     }
	     }
    | <RIGHT>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveHorizontally(x, false) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(-x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(x, false) ;
		      else 
		      	world.moveVertically(-x, false) ;
		  	}
	     }
    | <FRONT>
	     { if (ejecutar)
	       	world.moveForward(x, false) ;
	     }
    | <BACK>
	    { if (ejecutar)
	    	{ 
		      if (world.getFacing()==0)
		      	world.moveVertically(x, false) ;
		      else if (world.getFacing()==1)
		      world.moveVertically(-x, false) ;
		      else if (world.getFacing()==2)
		      	world.moveHorizontally(-x, false) ;
		      else 
		      	world.moveHorizontally(x, false) ;
		   }
	     }
}

void moveDirectionNESW(int x, boolean ejecutar):
{
}
{
		<EAST >
			 { if (ejecutar)
			 	{ world.moveHorizontally(x, false);
			 	changeFace(2); }
			}
		|  <WEST >
			{ if (ejecutar)
				{ world.moveHorizontally(-x, false);
				changeFace(3); }
			}
		|  <NORTH >
			{ if (ejecutar)
				{  world.moveVertically(-x, false);
				changeFace(0); }
			}
		| <SOUTH >
			{ if (ejecutar)
				{ world.moveVertically(x, false);
				changeFace(1); }
			}
}

void moveIndirTothe(int x, boolean ejecutar):
{
}
{
  < INDIR > moveDirectionNESW(x, ejecutar)
	| < TOTHE > moveDirectionLRFB(x, ejecutar)
	| { if (ejecutar)
			world.moveForward(x, false); }
}

void jumpIndirTothe(int x, boolean ejecutar):
{
}
{
        < INDIR > jumpDirectionNESW(x,ejecutar)
	| < TOTHE > jumpDirectionLRFB(x,ejecutar)
    | { world.moveForward(x, true); }
}


void jumpDirectionNESW(int x, boolean ejecutar):
{
}
{
		 <EAST >
		  { if (ejecutar)
		  	{ world.moveHorizontally(x, true);
		  	changeFace(2); }
		  }
		| <WEST >
			{ if (ejecutar)
				{ world.moveHorizontally(-x, true);
				changeFace(3); }
			}
		| <NORTH >
			{ if (ejecutar)
				{ world.moveVertically(-x, true);
				changeFace(0); }
			}
		| <SOUTH >
			{if (ejecutar)
				{  world.moveVertically(x, true);
				changeFace(1); }
			}
}

void jumpDirectionLRFB(int x, boolean ejecutar):
{
}
{
    <LEFT>
	    { if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveHorizontally(-x, true) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(-x, true) ;
		      else 
		      	world.moveVertically(x, true) ; }
	     }
    | <RIGHT>
	    {if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveHorizontally(x, true) ;
		      else if (world.getFacing()==1)
		      	world.moveHorizontally(-x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveVertically(x, true) ;
		      else 
		      	world.moveVertically(-x, true) ; }
	     }
    | <FRONT>
	     {if (ejecutar)
	       	world.moveForward(x, true) ;
	     }	
    | <BACK>
	    { if (ejecutar)
		      { if (world.getFacing()==0)
		      	world.moveVertically(x, true) ;
		      else if (world.getFacing()==1)
		      world.moveVertically(-x, true) ;
		      else if (world.getFacing()==2)
		      	world.moveHorizontally(-x, true) ;
		      else 
		      	world.moveHorizontally(x, true) ; }
	     }
}

void directionNSEW():
{
}
{
    <NORTH> | <SOUTH> | <EAST> | <WEST> 
}



void variable_declaration():
{
}
{
    <ID> ("," <ID>)* ":=" expr() "."
}

/*
void assignment():
{
}
{
    <ID> ":=" expr() "."
}
*/

void conditional(Console sistema, String procName):
{
  boolean bool;
  int numNot=0;
  boolean ejecutableIf=true;
  boolean ejecutableThen=false;
}
{
    <IF> numNot=notCondition() bool=conditions()
    	{
    	  if (numNot%2!=0)
    	  	bool=!bool;
    	  if (bool)
    		{ ejecutableIf= true;
			ejecutableThen=false;
			}
		else
			{ ejecutableIf=false;
			ejecutableThen=true;
			}
    	}
    <THEN> "[" ( interna(sistema, ejecutableIf, 1, procName) )* "]" (<ELSE> "[" (interna(sistema, ejecutableThen, 1, procName))* "]")?
    
}

void loop(Console sistema, String procName):
{
    boolean bool;
    int numNot = 0;
    boolean ejecutable;
    int repeticiones;
}
{
    // WHILE LOOP
    <WHILE> numNot = notCondition() bool = conditions()
    {
        if (numNot % 2 != 0) {
            bool = !bool;
        }
        ejecutable = bool;
    }
    <DO> "[" 
        { 
            while (ejecutable) {
                if (!interna(sistema, true, 1, procName)) break; // Control de ejecución
                ejecutable = conditions(); // Reevaluar condición en cada iteración
            }
        } 
        ( <BREAK> "." { return; } | <CONTINUE> "." { continue; } )*
    "]"

    | 
    // FOR LOOP
    <FOR> repeticiones = expr(procName) <REPEAT_BLOCK> "[" 
        { 
            for (int i = 0; i < repeticiones; i++) {
                if (!interna(sistema, true, 1, procName)) break; // Permitir interrupción
            }
        } 
        ( <BREAK> "." { return; } | <CONTINUE> "." { continue; } )*
    "]"
}


int notCondition():
{
  int total=0;
}
{
	(<NOT> { total+=1; } )*

	{return total; }
}

boolean conditions():
{
  int x=0;
  boolean bool;
}
{	  <CANMOVE> x=expr() bool=canMoveInDirToTheCondition(x) "." { return bool; }
	  |  <FACING>  bool=facingCondition() "." { return bool; }
	  |  <CANPUT> x=expr() < OFTYPE >  bool=canPutCondition( x) "." { return bool; }
	  |  <CANPICK> x=expr() < OFTYPE >  bool=canPickCondition( x) "." { return bool; }
	  |  <CANJUMP> x=expr()  bool=canJumpInDirToTheCondition(x) "." { return bool; }
	
}

boolean canJumpInDirToTheCondition(int x):
{
  boolean bool;
}
{
	< INDIR > bool=canJumpNESWCondition(x) { return bool; }
	| < TOTHE > bool=canJumpLRFBCondition(x) { return bool; }
}

boolean canJumpNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() ||  world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canJumpLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1 || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;
		 
		  if (newP > world.getN() || newP<1  || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}


boolean canMoveNESWCondition(int steps):
{
  Point pos;
  int newY;
  int newX;
}
{
	<SOUTH >
		{
		  pos=world.getPosition();
		  newY=pos.y+steps;
		  if (newY > world.getN() || world.blockedInRange(pos.x, pos.y, newY, SOUTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	|< NORTH >
		{
		  pos=world.getPosition();
		  newY=pos.y- steps;
		  if (newY< 1 || world.blockedInRange(pos.x, pos.y, newY, NORTH) || world.isBlocked(new Point(pos.x, newY)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < EAST >
		{
		  pos=world.getPosition();
		  newX=pos.x+ steps;
		  if (newX > world.getN() || world.blockedInRange(pos.x, pos.y, newX, EAST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;
		  
		}
	| < WEST >
		{
		  pos=world.getPosition();
		  newX=pos.x- steps;
		  if (newX< 1 || world.blockedInRange(pos.x, pos.y, newX, WEST) || world.isBlocked(new Point(newX, pos.y)))
		  	return false; 
		  else
		  	return true;	  
		}
}

boolean canMoveLRFBCondition(int steps):
{
  Point pos;
  Point newPos;
  int newP;
  int cardinalDir;
}
{
	<LEFT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "LEFT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("LEFT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	|< RIGHT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "RIGHT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("RIGHT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < FRONT >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "FRONT");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("FRONT");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
	| < BACK >
		{
		  pos=world.getPosition();
		  newPos= getNewPos( steps, "BACK");
		  
		  if (newPos.x==pos.x)
		  	newP=newPos.y;
		  else
		  	newP=newPos.x;

		 cardinalDir= getCardinalDirHeaded("BACK");
		 
		  if (newP > world.getN() || newP<1 || world.blockedInRange(pos.x, pos.y, newP, cardinalDir) || world.isBlocked(newPos) )
		  	return false; 
		  else
		  	return true;
		  
		}
}

int getCardinalDirHeaded(String dir):
{int facing;}
{
  {
  facing=world.getFacing();
  if (dir=="FRONT")
	return world.getFacing();

  else if (dir=="BACK")
  {
	if (facing==0)
		return 1;
	else if (facing==1)
		return 0;
	else if (facing==2)
		return 3;
	else
		return 2;
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		return 3;
	else if (facing==1)
		return 2;
	else if (facing==2)
		return 1;
	else 
		return 0;
		
  }
  
  else 
  {
	if (facing==0)
		return 2;
	else if (facing==1)
		return 3;
	else if (facing==2)
		return 0;
	else 
		return 1;
		
  }
  
} }

Point getNewPos( int steps, String dir):
{}
{
  {
  Point newPos= new Point(1,1);
  Point oldPos= world.getPosition();
  int facing = world.getFacing();

  if (dir=="FRONT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y-steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==2)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x-steps, oldPos.y);
		
  }

  else if (dir=="BACK")
  {
	if (facing==0)
		newPos= new Point (oldPos.x, oldPos.y+steps);
	else if (facing==1)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==2)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==3)
		newPos=new Point (oldPos.x+steps, oldPos.y);
		
  }

  else if (dir=="LEFT")
  {
	if (facing==0)
		newPos= new Point (oldPos.x-steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x+steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y+steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y-steps);
		
  }
  
  else 
  {
	if (facing==0)
		newPos= new Point (oldPos.x+steps, oldPos.y);
	else if (facing==1)
		newPos=new Point (oldPos.x-steps, oldPos.y);
	else if (facing==2)
		newPos=new Point (oldPos.x, oldPos.y-steps);
	else if (facing==3)
		newPos=new Point (oldPos.x, oldPos.y+steps);
		
  }
  
  return newPos;
  
}
}

boolean canMoveInDirToTheCondition(int x):
{  boolean bool;
}
{
	< INDIR > bool=canMoveNESWCondition( x) { return bool; }
	| < TOTHE > bool=canMoveLRFBCondition( x) { return bool ;}
}

boolean canPutCondition(int x):
{
}
{
  < BALLOONS > {if ( world.getMyBalloons()< x) return false; else return true; }
	|  < CHIPS > { if (x > world.freeSpacesForChips() ||  world.getMyChips()< x) return false; else return true;}
}

boolean canPickCondition(int x):
{
}
{
  < BALLOONS > { if (x > world.countBalloons()) return false; else return true;}
	|  < CHIPS > { if (x > world.chipsToPick()) return false; else return true;}
}

boolean facingCondition():
{
}
{
	< NORTH > { return world.facingNorth(); }
	| <SOUTH> { return world.facingSouth(); }
	| < EAST > { return world.facingEast(); }
	| < WEST > { return world.facingWest(); }
}

int expr(String procName):
{
    int total = 0;
    int valor;
    Token operador;
}
{
    valor = factor(procName) { total = valor; }
    ( operador = (<"+" | "-">) valor = factor(procName)
      { 
        if (operador.image.equals("+")) total += valor;
        else total -= valor; 
      }
    )*
    { return total; }
}

int factor(String procName):
{
    int total = 0;
}
{
    ( <NUM> { total = Integer.parseInt(token.image); }
    | <ID> {
        if (!variables.containsKey(token.image) && (procName.isEmpty() || !varExiste(procName, token.image))) {
            throw new Error("Variable no definida: " + token.image);
        }
        total = variables.containsKey(token.image) ? variables.get(token.image) : 0;
    })
    { return total; }
}


void changeFace(int dir):
{
}
{
  {
    while (world.getFacing()!=dir)
		world.turnRight();
  }
}

void faceDirections(boolean ejecutar):
{
}
{
 		 <WEST >  { if (ejecutar) changeFace(3); }
		|  <EAST >  { if (ejecutar) changeFace(2); }
		|  <NORTH >  { if (ejecutar) changeFace(0); }
		| <SOUTH >  { if (ejecutar) changeFace(1); }
}

void turnDirections(boolean ejecutar):
{
}
{
  	 <RIGHT>  { if (ejecutar) world.turnRight();}
  	| < LEFT >
  		{ if (ejecutar)
	    	{ world.turnRight();
	    	world.turnRight();
	    	world.turnRight();}
	  	}
  	| < AROUND >
  		{ if (ejecutar)
	    	{ world.turnRight();
	    	 world.turnRight(); }
	  	}
}





  
